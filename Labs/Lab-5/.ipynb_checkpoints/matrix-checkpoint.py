{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "class matrix:\n",
    "    \n",
    "    def __init__(self,n=1,m=1):\n",
    "        self.n=n  \n",
    "        self.m=m   \n",
    "        self.M = [[0.0 for i in range(self.m)] for i in range(self.n)]\n",
    "        \n",
    "    def PrintM(self):\n",
    "        for x in self.M:\n",
    "            print x\n",
    "        \n",
    "    def constant(self,c):\n",
    "        self.M= [[float(c)for i in range(self.m)]  for i in range(self.n)]\n",
    "        return self.M\n",
    "    \n",
    "    def zeros(self):\n",
    "        return [[0.0 for i in range(self.m)]  for i in range(self.n)]\n",
    "    \n",
    "    def ones(self):\n",
    "        return [[1.0 for i in range(self.m)] for i in range(self.n)]\n",
    "    \n",
    "    def eye(self):\n",
    "        Identity=[[0.0 for i in range(self.n)] for i in range(self.n)]\n",
    "        for i in range(0,self.n):\n",
    "                Identity[i][i]=1.0\n",
    "        return Identity\n",
    "    \n",
    "    def Shape(self,M=list()):\n",
    "        FindingRow=True\n",
    "        FindingColumn=True\n",
    "        shape=0\n",
    "        ######## iterating n and m till i find number of rows and colums. I know it will go out of index so i add a try and except###\n",
    "        try:\n",
    "            while FindingRow==True:\n",
    "                try:\n",
    "                    while FindingColumn==True:\n",
    "                        self.M[0][self.m]\n",
    "                        self.m+=1\n",
    "                except IndexError:\n",
    "                    FindingColumn=False\n",
    "                self.M[self.n][0]\n",
    "                self.n+=1\n",
    "        except IndexError:\n",
    "            FindingRow=False\n",
    "        size=(self.n,)+(self.m,)  \n",
    "        ######### Now testing that the matrix was made correctly ########\n",
    "        for i in range(0,self.n):\n",
    "            if len(self.M[i]) !=self.m:\n",
    "                return False\n",
    "        return size\n",
    "    \n",
    "    def row(self,n):\n",
    "        return self.M[n]\n",
    "    \n",
    "    def column(self,n):\n",
    "        self.Shape(self.M)\n",
    "        hold=[]\n",
    "        for i in range(0,self.Shape(self.M)):\n",
    "            hold.append(self.M[i][n])\n",
    "        return hold\n",
    "    \n",
    "    def block(self,n_0,n_1,m_0,m_1):\n",
    "        hold=[[0 for i in range (n_1-n_0+1)]  for j in range(m_1-m_0+1)]\n",
    "        x=0\n",
    "        y=0\n",
    "        try:\n",
    "            for m in range(m_0,m_1+1):\n",
    "                for n in range(n_0,n_1+1):\n",
    "                    hold[x][y]=self.M[m][n]\n",
    "                    y+=1\n",
    "                y=0\n",
    "                x+=1\n",
    "        except IndexError:\n",
    "            return \"failed\"\n",
    "        return hold\n",
    "    \n",
    "    def transpose(self):\n",
    "        Size=self.Shape(self.M)\n",
    "        P=[[0 for i in range (Size[0])] for j in range(Size[1])]\n",
    "        if Size==False:\n",
    "            return \"failed\"\n",
    "        hold=[[0 for i in range (Size[0])]   for j in range(Size[1])]\n",
    "        for i in range(Size[0]):\n",
    "            for j in range(Size[1]):\n",
    "                hold[j][i]=self.M[i][j]\n",
    "        P=list(hold)\n",
    "        return P\n",
    "    \n",
    "    def __mul__(self,c):\n",
    "        Size=self.Shape(self.M)\n",
    "        P=[[0 for i in range (Size[0])] for j in range(Size[1])]\n",
    "        if Size==False:\n",
    "            return \"failed\"\n",
    "        for i in range(Size[0]):\n",
    "            for j in range(Size[1]):\n",
    "                P[i][j]=self.M[i][j]*c\n",
    "        return P\n",
    "    \n",
    "    def __add__(self,N):\n",
    "        Size_M=self.Shape(self.M)\n",
    "        Size_N=self.Shape(N)\n",
    "        if Size_N==False or Size_M==False:\n",
    "            return \"failed\"\n",
    "        P=[[0.0] * self.m for i in range(self.n)]\n",
    "        if Size_M[0]==Size_N[0] and Size_M[1]==Size_N[1]:\n",
    "            for i in range(Size_M[0]):\n",
    "                for j in range(Size_M[1]):\n",
    "                    P[i][j]=self.M[i][j]+N[i][j]\n",
    "        else:\n",
    "            return \"matrix not same size\"\n",
    "        return P\n",
    "\n",
    "    def __sub__(self,N):\n",
    "         N=self.__mul__(-1)\n",
    "        P=self.__add__(N)        \n",
    "        return P\n",
    "    \n",
    "    def elementmult(self,N):\n",
    "        Size_M=self.Shape(self.M)\n",
    "        Size_N=self.Shape(N)\n",
    "        P=[[0.0] * self.m for i in range(self.n)]\n",
    "        if Size_M[0]==Size_N[0] and Size_M[1]==Size_N[1]:\n",
    "            for i in range(Size_M[0]):\n",
    "                for j in range(Size_M[1]):\n",
    "                    P[i][j]=self.M[i][j]*N[i][j]\n",
    "        else:\n",
    "            return \"failed\"\n",
    "        return P\n",
    "    \n",
    "    def __matmult__(self,N):\n",
    "        Size_M=self.Shape(self.M)\n",
    "        Size_N=self.Shape(N)\n",
    "        print Size_N\n",
    "        K=[[0 for i in range(Size_N[1])]  for i in range(Size_M[0])]\n",
    "        x=0\n",
    "        Hold_Sum=0\n",
    "        if Size_M[1]==Size_N[0]:\n",
    "            P=list(self.transpose())\n",
    "            for k in range(Size_M[0]):\n",
    "                for j in range(Size_N[1]):\n",
    "                    for i in range(Size_N[0]):\n",
    "                        Hold_num=P[i][k]*N[i][j]\n",
    "                        Hold_Sum=Hold_Sum+Hold_num \n",
    "                    K[k][j]=Hold_Sum\n",
    "                    Hold_Sum=0\n",
    "        else:\n",
    "            return \"failed\"\n",
    "        return K\n",
    "    \n",
    "    def rand(self,n,m):\n",
    "        import random\n",
    "        K=[[0.0 for i in range(m)]   for j in range(n)]\n",
    "        for i in range (n):\n",
    "            for j in range (m):\n",
    "                K[i][j]=random.random()\n",
    "   \n",
    "        return K\n",
    "\n",
    "        \n",
    "    def compare(M):\n",
    "        a=len(M)\n",
    "        for i in range(0,a):\n",
    "             if abs(M[i][i]-1)>0.1:\n",
    "                    return False\n",
    "        return True\n",
    "    def copy(M):\n",
    "        n=len(M)\n",
    "        out=[[0 for i in range(n)] for j in range(n)]\n",
    "        for i in range (0,n):\n",
    "            for j in range (0,n):\n",
    "                out[i][j]=M[i][j]\n",
    "        return out\n",
    "    def inv(self):\n",
    "     \n",
    "        A=self.copy(M)\n",
    "     \n",
    "     \n",
    "     \n",
    "     \n",
    "        p=0\n",
    "        d=1\n",
    "        while True: \n",
    "                if p>=len(M):\n",
    "                    break\n",
    "                if M[p][p]==0:\n",
    "                    break\n",
    "                d=d*M[p][p]\n",
    "             \n",
    "                    \n",
    "                for i in range (0,len(M)):\n",
    "                    if i!=p:\n",
    "                        M[i][p]=-M[i][p]/M[p][p]\n",
    "                   \n",
    "                for i in range (0,len(M)):\n",
    "                    for j in range (0,len(M)):\n",
    "                        if i!=p and j!=p:\n",
    "                            M[i][j]=M[i][j]+M[p][j]*M[i][p]\n",
    "                for j in range (0,len(M)):\n",
    "                    if j!=p:\n",
    "                        M[p][j]=M[p][j]/M[p][p]            \n",
    "                M[p][p]=1.0/M[p][p]\n",
    "            \n",
    "                p=p+1\n",
    "                if self.compare(matmult(M,A)):   \n",
    "                    print 'yes'\n",
    "                    return M\n",
    "     \n",
    "    \n",
    "        print \"nope\"\n",
    "        return False\n",
    "\n",
    "\n",
    "\n",
    "class Vector(Matrix):\n",
    "    def __init__(self,A=list(),B=list()):\n",
    "        self.A=A\n",
    "        self.B=B\n",
    "        \n",
    "    def dot(self):\n",
    "        Size_A=len(self.A)\n",
    "        Size_B=len(self.B)\n",
    "        Hold_Sum=0\n",
    "        if Size_A==Size_B:\n",
    "            for i in range(Size_A):\n",
    "                Hold_Sum=Hold_Sum+(self.A[i]*self.B[i])\n",
    "        else:\n",
    "            \"failed\"\n",
    "        return Hold_Sum\n",
    "\n",
    "    def outer(self):\n",
    "        Size_A=len(self.A)\n",
    "        Size_B=len(self.B)\n",
    "        P=[[0] * len(self.A) for i in range(len(self.A))]\n",
    "        if Size_A==Size_B:\n",
    "            for i in range(Size_A):\n",
    "                for j in range(Size_A):\n",
    "                    P[i][j]=self.A[i]*self.B[j]\n",
    "        else:\n",
    "            \"failed\"\n",
    "        return P\n",
    "    \n",
    "     \n",
    "        \n",
    "    \n",
    "    def norm(self,A,i):\n",
    "        import math\n",
    "        hold=0\n",
    "        for j in range(0,len(A)):\n",
    "            A[j]=abs(A[j])\n",
    "        if i==0:\n",
    "            for j in range(0,len(A)):\n",
    "                if [j]>hold:\n",
    "                    hold=A[j]\n",
    "            return hold\n",
    "\n",
    "\n",
    "        else:\n",
    "            for j in range(0,len(A)):\n",
    "                z=A[j]**i\n",
    "                hold=hold+z\n",
    "            hold=float(hold)**(1.0/i)\n",
    "            return hold\n",
    "        "
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 2",
   "language": "python",
   "name": "python2"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 2
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython2",
   "version": "2.7.15"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
